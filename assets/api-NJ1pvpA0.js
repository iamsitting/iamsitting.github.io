const c=new Map;function l(r){return c.has(r)||c.set(r,c.size+1),c.get(r)}async function p(){const r=await fetch("/posts.version.json");if(!r.ok)throw new Error("Failed to fetch posts version");const{version:e}=await r.json(),o=await fetch(`/posts.${e}.json`);if(!o.ok)throw new Error("Failed to fetch posts");return o.json()}async function w(){const r=await fetch("/papers.version.json");if(!r.ok)throw new Error("Failed to fetch papers version");const{version:e}=await r.json(),o=await fetch(`/papers.${e}.json`);if(!o.ok)throw new Error("Failed to fetch papers");return o.json()}const f=async(r=1,e="",o)=>{try{let t=await p();if(e){const a=e.toLowerCase();t=t.filter(s=>s.title.toLowerCase().includes(a)||s.description.toLowerCase().includes(a))}o&&(t=t.filter(a=>a.categories.some(s=>{const h=Array.isArray(s.name)?s.name[0]:s.name;return l(h)===o}))),t.sort((a,s)=>new Date(s.publishedAt).getTime()-new Date(a.publishedAt).getTime());const n=(r-1)*10,i=n+10;return{posts:t.slice(n,i),pagination:{page:r,pageSize:10,pageCount:Math.ceil(t.length/10),total:t.length}}}catch(t){throw console.error("Error fetching posts:",t),new Error("Server error")}},u=async r=>{try{return(await p()).find(t=>t.slug===r)||null}catch(e){throw console.error("Error fetching post:",e),new Error("Server error")}},d=async()=>{try{const r=await p(),e=new Map;return r.forEach(o=>{o.categories.forEach(t=>{const n=Array.isArray(t.name)?t.name[0]:t.name;if(!e.has(n)){const i=l(n);e.set(n,{documentId:i,name:n,description:""})}})}),Array.from(e.values())}catch(r){throw console.error("Error fetching categories:",r),new Error("Server error")}},E=async()=>{try{return(await w()).sort((e,o)=>new Date(o.publishedAt).getTime()-new Date(e.publishedAt).getTime())}catch(r){throw console.error("Error fetching papers:",r),new Error("Server error")}},y=async r=>{try{return(await w()).find(t=>t.slug===r)||null}catch(e){throw console.error("Error fetching paper:",e),new Error("Server error")}};export{d as a,u as b,E as c,y as d,f as g};
